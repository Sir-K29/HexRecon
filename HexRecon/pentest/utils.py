import os
import re
import datetime
import logging
import subprocess
import csv
from fpdf import FPDF  # Make sure fpdf is installed: pip install fpdf
from .config import LOG_FILE, REPORTS_DIR

# Global variable to store the currently running subprocess.
current_process = None

def setup_logging():
    """Setup logging to file and console."""
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        filename=LOG_FILE,
        filemode="a"
    )
    console = logging.StreamHandler()
    console.setLevel(logging.INFO)
    formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    console.setFormatter(formatter)
    logging.getLogger().addHandler(console)

def sanitize_url(url):
    """Remove protocols (http, https) and 'www.' from a URL."""
    return re.sub(r'^(https?:\/\/)?(www\.)?', '', url).rstrip('/')

def sanitize_filename(text):
    """Sanitize a string to be safe for filenames."""
    return re.sub(r'[^\w\-_. ]', '_', text)

def get_scan_directory(target):
    """
    Create and return the directory path for a scan:
    ScanResults/<sanitized_target>/<YYYY-MM-DD>/
    """
    sanitized_target = sanitize_url(target)
    today = datetime.date.today().strftime('%Y-%m-%d')
    directory = os.path.join("ScanResults", sanitized_target, today)
    os.makedirs(directory, exist_ok=True)
    return directory

def save_scan_results(tool_name, target, results, command=""):
    """Save tool scan results into a structured file.

    The filename format will be: tool_command_timestamp.txt
    """
    try:
        scan_directory = get_scan_directory(target)
        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        sanitized_tool = sanitize_filename(tool_name)
        sanitized_command = sanitize_filename(command) if command else "default"
        filename = f"{sanitized_tool}_{sanitized_command}_{timestamp}.txt"
        filepath = os.path.join(scan_directory, filename)
        with open(filepath, "w", encoding="utf-8") as file:
            file.write(results)
        return filepath
    except Exception as e:
        logging.error(f"Failed to save scan results for {tool_name} on {target}: {e}")
        return None

def read_targets(file_path):
    """Read targets from a file (one per line) and return a list."""
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"Targets file not found: {file_path}")
    with open(file_path, "r") as f:
        targets = [line.strip() for line in f if line.strip()]
    return targets

def detect_os():
    """Return the current OS as a string."""
    import platform
    return platform.system()

def export_results_csv(scan_results, output_file):
    """Export scan results to a CSV file."""
    keys = scan_results[0].keys() if scan_results else []
    with open(output_file, "w", newline='', encoding="utf-8") as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=keys)
        writer.writeheader()
        writer.writerows(scan_results)
    return output_file

def check_tool_installed(tool_name):
    """Check if an external tool is installed by trying to run its '--version' (or a basic command)."""
    try:
        subprocess.run([tool_name, "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=10)
        return True
    except Exception:
        return False

def install_tool(tool_name):
    """
    Attempt to install a missing tool using apt-get.
    Returns True if installation succeeded, False otherwise.
    """
    try:
        subprocess.run(["sudo", "apt-get", "install", "-y", tool_name], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return True
    except subprocess.CalledProcessError as e:
        logging.error(f"Installation of {tool_name} failed: {e}")
        return False

def run_command(cmd):
    """
    Run a shell command using subprocess.Popen so that it can be terminated.
    The global variable `current_process` stores the process so that it can be killed externally.
    """
    global current_process
    try:
        # Use preexec_fn=os.setsid to create a new process group (Linux only)
        current_process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, preexec_fn=os.setsid)
        stdout, stderr = current_process.communicate(timeout=60)
        retcode = current_process.returncode
        current_process = None
        return stdout if retcode == 0 else stderr
    except Exception as e:
        if current_process:
            try:
                # Terminate the entire process group.
                os.killpg(os.getpgid(current_process.pid), 2)
            except Exception:
                pass
        current_process = None
        return f"Error running command: {e}"

def generate_report_site(target, site_results):
    """
    Generate an HTML report for a specific target.
    The report groups results by tool: prints the tool header (with colors) once, then lists each command.
    """
    scan_directory = get_scan_directory(target)
    report_file = os.path.join(scan_directory, f"report_{datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.html")
    # Group results by tool
    grouped = {}
    for result in site_results:
        grouped.setdefault(result['tool'], []).append(result)
    with open(report_file, "w", encoding="utf-8") as f:
        f.write(f"""<html>
<head>
<title>Scan Report for {target}</title>
<style>
body {{ font-family: Arial, sans-serif; background-color: #f2f2f2; margin: 20px; }}
h1 {{ color: #333; }}
.tool-header {{ background-color: #4CAF50; color: white; padding: 5px; margin-top: 10px; }}
.command-header {{ background-color: #2196F3; color: white; padding: 3px; }}
pre {{ background-color: #e0e0e0; padding: 10px; border-radius: 5px; }}
</style>
</head>
<body>
<h1>Scan Report for {target}</h1>
""")
        for tool, results in grouped.items():
            # Tool header once.
            f.write(f"<div class='tool-header'><h2>{tool}</h2></div>\n")
            for res in results:
                f.write(f"<div class='command-header'>Command: {res['command']}</div>\n")
                f.write(f"<pre>{res['output']}</pre>\n")
        f.write("</body></html>")
    return report_file

def generate_report_site_pdf(target, site_results):
    """
    Generate a PDF report for a specific target.
    The PDF report is structured similarly to the HTML version.
    """
    scan_directory = get_scan_directory(target)
    pdf_file = os.path.join(scan_directory, f"report_{datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.pdf")
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", 'B', 16)
    pdf.cell(0, 10, f"Scan Report for {target}", ln=True, align="C")
    pdf.ln(5)
    
    # Group results by tool.
    grouped = {}
    for result in site_results:
        grouped.setdefault(result['tool'], []).append(result)
    for tool, results in grouped.items():
        pdf.set_font("Arial", 'B', 14)
        pdf.set_fill_color(76, 175, 80)  # Same green as HTML header.
        pdf.cell(0, 10, tool, ln=True, fill=True)
        for res in results:
            pdf.set_font("Arial", 'B', 12)
            pdf.set_fill_color(33, 150, 243)  # Blue for command.
            pdf.cell(0, 8, f"Command: {res['command']}", ln=True, fill=True)
            pdf.set_font("Arial", '', 12)
            pdf.multi_cell(0, 8, res['output'])
            pdf.ln(2)
        pdf.ln(5)
    pdf.output(pdf_file)
    return pdf_file
